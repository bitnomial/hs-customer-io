{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeOperators #-}

module Customer.IO.Track (
    -- * Client
    CustomerIOClient (..),
    createTrackClient,
    createOrUpdatePerson,
    trackCustomerEvent,

    -- * Types
    CustomerIOTrackAuth (..),
    EntityRequest (..),
    PersonEntity (..),
    EventRequest (..),
    EventEntity (..),
    EventType (..),

    -- * Helpers
    event,
    pageEvent,
    screenEvent,

    -- * Errors
    CustomerIOError (..),
) where

import Control.Monad.IO.Class (liftIO)
import Data.Aeson (ToJSON)
import Data.Aeson qualified as Aeson
import Data.Map (Map)
import Data.Maybe (fromMaybe)
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import Data.Text.Encoding qualified as T
import GHC.Generics (Generic)
import Network.HTTP.Client.TLS (newTlsManager)
import Servant.API (
    BasicAuth,
    BasicAuthData (..),
    Capture,
    JSON,
    NoContent (..),
    Post,
    ReqBody,
    (:>),
 )
import Servant.Client (
    ClientEnv,
    ClientError,
    ClientM,
    client,
    mkClientEnv,
    parseBaseUrl,
    runClientM,
 )


-- | Authentication credentials for Customer.io
data CustomerIOTrackAuth = CustomerIOTrackAuth
    { siteId :: Text
    -- ^ Your Customer.io Site ID
    , apiKey :: Text
    -- ^ Your Customer.io API Key
    }
    deriving (Show)


-- | Person entity for the v2 API
data PersonEntity = PersonEntity
    { personType :: Text
    -- ^ Always "person"
    , personAction :: Text
    -- ^ "identify" to create/update
    , personIdentifiers :: Map Text Text
    -- ^ Person identifiers (id, email, etc.)
    , personAttributes :: Map Text Aeson.Value
    -- ^ Person attributes
    }
    deriving (Show, Generic)


instance ToJSON PersonEntity where
    toJSON (PersonEntity pType pAction idents attrs) =
        Aeson.object
            [ "type" Aeson..= pType
            , "action" Aeson..= pAction
            , "identifiers" Aeson..= idents
            , "attributes" Aeson..= attrs
            ]


    toEncoding (PersonEntity pType pAction idents attrs) =
        Aeson.pairs $
            mconcat
                [ "type" Aeson..= pType
                , "action" Aeson..= pAction
                , "identifiers" Aeson..= idents
                , "attributes" Aeson..= attrs
                ]


-- | Request body for the v2 entity endpoint
newtype EntityRequest = EntityRequest PersonEntity
    deriving (Show, Generic)


instance ToJSON EntityRequest where
    toJSON (EntityRequest person) = Aeson.toJSON person


-- | Customer.io API errors
newtype CustomerIOError = CustomerIOError ClientError
    deriving (Show)


-- | The v2 entity endpoint - POST /api/v2/entity
type EntityAPI =
    "api"
        :> "v2"
        :> "entity"
        :> BasicAuth "customer-io" ()
        :> ReqBody '[JSON] EntityRequest
        :> Post '[JSON] NoContent


-- | Simple Customer.io client
data CustomerIOClient = CustomerIOClient
    { clientAuth :: CustomerIOTrackAuth
    , clientEnv :: ClientEnv
    }


-- | Create a Customer.io client with hardcoded track.customer.io URL
createTrackClient :: CustomerIOTrackAuth -> IO CustomerIOClient
createTrackClient auth = do
    manager <- newTlsManager
    let baseUrl = fromMaybe (error "Invalid hardcoded URL") $ parseBaseUrl "https://track.customer.io"
        env = mkClientEnv manager baseUrl
    pure $ CustomerIOClient auth env


-- | Create or update a person using the v2 entity endpoint
createOrUpdatePerson ::
    CustomerIOClient ->
    -- | Identifiers (email, id, etc.)
    Map Text Text ->
    -- | Attributes
    Map Text Aeson.Value ->
    IO (Either CustomerIOError ())
createOrUpdatePerson trackClient identifiers attrs = do
    let person =
            PersonEntity
                { personType = "person"
                , personAction = "identify"
                , personIdentifiers = identifiers
                , personAttributes = attrs
                }
        request = EntityRequest person
        basicAuth =
            BasicAuthData
                (T.encodeUtf8 $ siteId $ clientAuth trackClient)
                (T.encodeUtf8 $ apiKey $ clientAuth trackClient)
    liftIO $
        runClientM (entityClient basicAuth request) (clientEnv trackClient) >>= \case
            Left err -> pure . Left $ CustomerIOError err
            Right NoContent -> pure $ Right ()


-- | Internal client function generated by servant-client
entityClient :: BasicAuthData -> EntityRequest -> ClientM NoContent
entityClient = client (Proxy :: Proxy EntityAPI)


type EventName = Text


data EventType
    = -- | Event related to website page view
      PageEvent
    | -- | Event related to a mobile app screen view
      ScreenEvent
    | -- | Nondescript event
      Event
    deriving (Eq, Show, Enum, Bounded)


instance ToJSON EventType where
    toJSON PageEvent = Aeson.toJSON @Text "page"
    toJSON ScreenEvent = Aeson.toJSON @Text "screen"
    toJSON Event = Aeson.toJSON @Text "event"


    toEncoding PageEvent = Aeson.toEncoding @Text "page"
    toEncoding ScreenEvent = Aeson.toEncoding @Text "screen"
    toEncoding Event = Aeson.toEncoding @Text "event"


-- | Representation of an event. See `event`, `pageEvent`, and `screenEvent` to create
-- an `EventEntity`.
--
-- Note that this is specific to the v1 Track API. The v2 Track API is a lot more general
data EventEntity
    = EventEntity
    -- Note that we do not support all optional fields of `EventRequest`.
    { eventEntityName :: EventName
    -- ^ The name of the event. This is how you'll reference the event in campaigns or segments.
    -- Leading and trailing spaces are trimmed from event names.
    , eventEntityType :: Maybe EventType
    -- ^ Event type. Default is a nondescript `Event`.
    , eventEntityData :: Map Text Aeson.Value
    -- Additional information that you might want to reference in a message using liquid or use to set attributes on your customer
    }
    deriving (Eq, Show)


newtype EventRequest = EventRequest EventEntity


instance ToJSON EventRequest where
    toJSON (EventRequest eventEntity) = Aeson.toJSON eventEntity


instance ToJSON EventEntity where
    toJSON (EventEntity name type_ data_) =
        Aeson.object ["name" Aeson..= name, "type" Aeson..= type_, "data" Aeson..= data_]


    toEncoding (EventEntity name type_ data_) =
        Aeson.pairs $ mconcat ["name" Aeson..= name, "type" Aeson..= type_, "data" Aeson..= data_]


type Identifier = Text


-- Tracking event API
--
-- https://docs.customer.io/integrations/api/track/#tag/Track-Events
type EventAPI =
    "api"
        :> "v1"
        :> "customers"
        :> Capture "identifier" Identifier
        :> "events"
        :> BasicAuth "customer-io" ()
        :> ReqBody '[JSON] EventRequest
        :> Post '[JSON] NoContent


event :: EventName -> Map Text Aeson.Value -> EventEntity
event name = EventEntity name (Just Event)


pageEvent :: EventName -> Map Text Aeson.Value -> EventEntity
pageEvent name = EventEntity name (Just PageEvent)


screenEvent :: EventName -> Map Text Aeson.Value -> EventEntity
screenEvent name = EventEntity name (Just ScreenEvent)


-- | Track a customer event.
--
-- See `event`, `pageEvent`, and `screenEvent` to create
-- an `EventEntity`.
--
-- = Reserved Properties
--
-- There are a few important values which, if sent with the events that trigger campaigns, will override your campaign settings:
--
-- * @from_address@
-- * @recipient@
-- * @reply_to@
trackCustomerEvent ::
    CustomerIOClient ->
    -- | Person identifier (email, id, etc.)
    Identifier ->
    EventEntity ->
    IO (Either CustomerIOError ())
trackCustomerEvent trackClient identifier ev = do
    let basicAuth =
            BasicAuthData
                (T.encodeUtf8 $ siteId $ clientAuth trackClient)
                (T.encodeUtf8 $ apiKey $ clientAuth trackClient)
    liftIO $
        runClientM (eventClient identifier basicAuth (EventRequest ev)) (clientEnv trackClient) >>= \case
            Left err -> pure . Left $ CustomerIOError err
            Right NoContent -> pure $ Right ()
  where
    -- \| Internal client function generated by servant-client
    eventClient :: Identifier -> BasicAuthData -> EventRequest -> ClientM NoContent
    eventClient = client (Proxy :: Proxy EventAPI)